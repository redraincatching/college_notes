summary of the code
    - program reads in input
    - calls hash function with input as argument
        res = hashF1(args[0]);
    - hash checks to see if string is within the specified length parameters
        if ((s.length() > 64) || (s.length() < 1)) { // String does not have required length
            ret = -1;
        }
    - hash adds filler characters to the input string, and then takes the first 64 
    - hash also initialises an array of integers, HashA to 1, 1, 1, 1
    - for each character in this new string, hash multiplies its ascii value by a seemingly random number, and adds that to the value of the integers in the array HashA, multiplying by a different number for each item
                hashA[0] += (byPos * 17);
                hashA[1] += (byPos * 31);
                hashA[2] += (byPos * 101);
                hashA[3] += (byPos * 79);
    - then, each item in the array is taken modulus 255
    - HashA[0] is added to HashA[1] * 256, plus HashA[2] * 256^2, plus HashA[3] * 256^3
    - this value is checked to be non-negative, and then returned
    - this returned integer is provided to the user as the hash value



source code

package ct255_assignment_1;
import java.util.Random;

public class HashFunction_1 {
	public static void main(String[] args) {
        int res = 0;

        if (args != null && args.length > 0) { // Check for <input> value
            res = hashF1(args[0]); // call hash function with <input>
            if (res < 0) { // Error
                System.out.println("Error: <input> must be 1 to 64 characters int.");
            }
            else {
                System.out.println("input = " + args[0] + " : Hash = " + res);
                System.out.println("Start searching for collisions");
                String[] found = collisions(res, 1);
                for (int i = 0; i < found.length; i++) {
                	System.out.println("collision found with string " + found[i]);
                }
            }
            int res_2 = hashF2(args[0]);
            if (res < 0) { // Error
                System.out.println("Error: <input> must be 1 to 64 characters int.");
            }
            else {
                System.out.println("input = " + args[0] + " : Hash = " + res_2);
                System.out.println("Start searching for collisions");
                String[] found = collisions(res, 2);
                if (found != null) {
                	for (int i = 0; i < found.length; i++) {
                    	System.out.println("collision found with string " + found[i]);
                    }
                }
            }
        }
        else { // No <input> 
            System.out.println("Use: CT255_HashFunction1 <Input>");
        } 
    }
        
    private static int hashF1(String s){
        int ret = -1, i;
        int[] hashA = new int[]{1, 1, 1, 1};
        
        String filler, sIn;
        
        filler = new String("ABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGHABCDEFGH");
        
        if ((s.length() > 64) || (s.length() < 1)) { // String does not have required length
            ret = -1;
        }
        else {
            sIn = s + filler; // Add characters, now have "<input>HABCDEF..."
            sIn = sIn.substring(0, 64); // // Limit string to first 64 characters
            // System.out.println(sIn); // FYI
            for (i = 0; i < sIn.length(); i++){
                char byPos = sIn.charAt(i); // get i'th character
                hashA[0] += (byPos * 17); // Note: A += B means A = A + B
                hashA[1] += (byPos * 31);
                hashA[2] += (byPos * 101);
                hashA[3] += (byPos * 79);
            } 
            
            hashA[0] %= 255;  // % is the modulus operation, i.e. division with rest
            hashA[1] %= 255;
            hashA[2] %= 255;
            hashA[3] %= 255;
            
            ret = hashA[0] + (hashA[1] * 256) + (hashA[2] * 256 * 256) + (hashA[3] * 256 * 256 * 256);
            if (ret < 0) ret *= -1;
        }
        return ret;
    }   

    
    private static int hashF2(String input) {
    	int[] hashB = new int[]{1, 1, 1, 1, 1, 1};
    	// hash array is now 6 ints
    	int ret_val = 0;
    	
    	char c_1, c_2, c_3;	// just wait
    	
    	String filler, working; 
    	
    	if ((input.length() < 1) || (input.length() > 64)) {
    		return -1;
    	}
    	else {    		
    		filler = "QWERTYUIOPASDyfFGHJKLZXCVBNMQWERTYUIOPASDFGHJLZXCVBNMqwertyuiop";
    		// nice
    		
    		working = input + filler;
    		working = working.substring(0, 64);
    		// cut to 64 chars
    		
    		for (int i = 0; i < working.length(); i++) {
    			c_1 = working.charAt(i);
    			c_2 = (i == 63) ? working.charAt(0) : working.charAt(i+1);
    			// using pairs of characters
    			
    			int char_3 = hashF1(input);
    			c_3 = working.charAt(char_3 % 63);
    			// using the hashF1 function, get c_3
    			
    			hashB[0] += (c_1 * c_2)* hashF1(working.substring(4,17));
    			// this is so efficient :)
    			hashB[1] += (c_1 * c_2) * 55;
    			hashB[2] += (c_1 ^ c_2) * 83;
    			hashB[3] += (c_1 * c_3) * 354;	// this one is char 3 :)
    			hashB[4] += (c_1 * c_2) * hashF1(working.substring(20, 33));
    			hashB[5] += (c_1 & c_2) * 77;
    			// i just added more ints and made it more stupidly complex
    		}
    		
    		hashB[0] %= 4096;  
            hashB[1] %= 4096;
            hashB[2] %= 4096;
            hashB[3] %= 4096;
            hashB[4] %= 4096;
            hashB[5] %= 4096;
            
            ret_val = (hashB[0] * 369) + (hashB[1] * 256) + (hashB[2] * 256 * 256) + (hashB[3] * 256 * 256 * 256) + (hashB[4] * 256 * 256 * 256 * 256) + (hashB[5] * 256 * 256 * 256 * 256);
            if (ret_val < 0) ret_val *= -1;
    	}
    	return ret_val;
    }

private static String[] collisions(int to_be_found, int hash) {
	String tester = "";		// string to be tested
	String[] results = {"","","","","","","","","","","","","","",""};	// first 15 collision go here
	int found = 0;			// count how many found
	int tests = 0;			// how many attempts
	int check_res = 0;			// the hash being tested
	
	int l_limit = 97;	// a
	int r_limit = 122;	// z
	
	Random random = new Random();
	
	while (found < 15) {
		tests++;
		tester = random.ints(l_limit, r_limit+1)
				.limit(7)	// started with 64, but 7 works quickly
				.collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append)
				.toString();
		
		// this just generates a string of 7 random lowercase letters
		
		switch (hash) { // usable for testing both functions
		case 1:
			check_res = hashF1(tester);
			break;
		case 2:
			check_res = hashF2(tester);
			break;
		default:
			break;
		}
		
		// tests that random string
		
		if ((check_res == to_be_found) && (tests <= 10000)) {
			results[found] = tester;
			found++;
			// if a string collides, add it to the results array
			System.out.println("collision found in " + tests + " attempts.");
			tests = 0;
		}
		
		if (tests > 10000) {
			System.out.println("10000 attempts exceeded with no collisions, exiting...");
			return null;
		}
	}
	
	return results;
	}

}
