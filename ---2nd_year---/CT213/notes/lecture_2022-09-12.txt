programming models
    a processor programming model defines how instructions access their operands and how instructions are described in the processor's assembly language

    processors with different programming models can offer similar sets of operations, but may require very different approaches to programming

the processor - instruction cycle
    fetch - decode - execute

    types of instructions
        - data transfer
            operations that move data from one place to another
            don't modify the data, just copy to the destination
        - data operation
            modify their data values
            perform some operation on operands, and stores the result
        - program control
            jump or branch instructions
            conditional changes to order of instruction execution

            data transfer instructions
                - load data from memory into the microprocessor, e.g. LD
                - store data from microprocessor into memory, e.g. ST
                - move data within the microprocessor, e.g. MOV
                    [[diagram]]
                - input to microprocessor from i/o device, e.g. IORD
                - output from microprocessor to i/o device, e.g. IOWR
                    [[diagram]]

            data operation
                - arithmetic
                    - add, subtract, multiply, divide
                        e.g. ADD, SUB, MUL, DIV
                    - increment or decrement a value
                        e.g. INC, DEC
                    - floating point arithmetic
                        e.g. FADD, FSUB, FMUL, FDIV

                - logic
                    e.g. ADD, OR, XOR, NOT, etc.

                - shift
                    e.g. SR, SL, RR, RL, etc.

            program control
                - jump and branch, conditional or unconditional, e.g.
                    - JZ: jump if zero flag
                    - JNZ: jump not zero
                    - JMP: jump, unconditional

                - comparison
                    e.g. TEST: logical BITWISE AND

                - calls and returns from a routine, conditional or unconditional
                    - CALL: call a routine at a certain line
                    - RET: return from a subroutine
                    - IRET: interrupt routine and return

                - software interrupts
                    generated by devices outside of the processor, therefore not part of the instruction set
                    called "hardware interrupts"
                    INT

                - exceptions and traps
                    triggered when valid instructions perform invalid operations, such as division by zero

                - halt instructions
                    causes the processor to stop
                    e.g. at the end of a program
                    HALT

the stack
    filo architecture (first in, last out)
    consists of locations which can hold a word of data
        can be used to explicitly save/restore data
    supports two operations
        push, and pop

    when new data is added to the stack, it is pushed onto the top, and the contents move down one location
    a pop command removes the contents of the top location, and moves all lower locations up one

    two ways to implement the stack
        1) dedicated hardware stack
            - limited by number of locations
            - very fast

        2) memory implemented stack
            - limited by physical memory of system
            - slow compared to hardware stack, extra memory addressing has to take place for each operation
                -> the top of the stack also has to move each time it changes

    stack overflow
        the amount of data in the stack exceeds the amount of space allocated to the stack, or the hardware limit

    instructions in a stack based architecture
        note: operations on the stack are destructive
            each instruction that alters the state of the stack is not reversible or repeatable

        advantages:
            code takes very little memory, as there is no need to specify addresses

        postfix notation necessary
        example
            given stack [a][b][c][d][e]
            in infix
                a*(b-c) + (d+e)
            in postfix
                a b c - * d e + +

            using instruction tree



                           +
                          / \
                         /   \
                        /     \
                       *       +
                      / \     / \
                     a   -   d   e
                        / \
                       b   c

            in stack-based instructions
                push a
                push b
                push c
                subtract
                multiply
                push d
                push e
                add
                add

general purpose register architecture
    the instructions read their operands and write their results to a random access register file
    the gpr file allows the access of any register in any order by specifying the register id
        the main difference between the stack and gpr is that repeatedly reading a register will not change the contents of that register

    gpr instructions need to specify
        - the register that holds the input operands
        - the register that will hold the result

        the most common format is the three-operand instruction format
            e.g. ADD r1, r2, r3 instructs the processor to read the contents of r1 and r2, add them, and store the result in r3

        a significant result difference between gpr and stack
            programs can choose which values should be stored in the register file, allowing them cache the most accessed data
                -> they can perform all of the necessary calculations, store them, and then access them all later
            in the stack, once the data has been used, it's gone
            gpr has better performance from this point of view, at the expense of needing more memory to encode the instructions

    programs in a gpr architecture
        less structured than stack-based architecture
        fewer restrictions on the order in which instructions can be executed
            -> this allows a compiler to reorder code to optimise it
            in gpr, any order that places the operands for the next instruction in the register file before the instruction execute is valid

        example
            2 + (7&3)

            MOV r1, #7
            MOV r2, #3
            AND r1, r2, r3          ;store result in r3
            MOV r4, #2
            ADD r3, r4, r4          ;and done

stack and gpr comparison
    stack
        - takes fewer bits to encode instructions
        - reduced amount of memory taken up by programs
        - automatic memory management
        - instruction set does not change if stack or word size changes

    gpr
        - as time passes, memory expenses become negligible
        - better performance, caching

    // stack-based processors are still attractive for some embedded systems

using stacks to implement procedure calls
    programs need a way to pass inputs to procedures as they are called
    procedures need to be able to allocate space for local variables
        it is impossible to determine what registers may be safely used by the procedure, especially if that procedure is located in a library
            -> therefore, a save/restore mechanism must be in place
    procedures also need a way to return to where they were called from

    [[diagram]]
        - when a procedure is called, a block of memory (a stack frame) is allocated
        - the top of the stack pointer is incremented by the number of locations in that frame
        - when the procedure finishes, it jumps back to the return address contained in the stack, and execution of the calling program used
