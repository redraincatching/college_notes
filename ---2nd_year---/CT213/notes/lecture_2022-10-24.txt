preventing deadlock
    global order of locks
        solution 1
            order based on hash code of variables
        solution 2
            order based on client with smallest id

    https://www.youtube.com/channel/UCBRYU9uye8e-ZuWQMPBAoYA/videos
    - mike swift: concurrency

classical problems of synchronisation
    - producer-consumer
        two types of processes
        - producer
            process that, from some inner activity, produces data to send to other processes
        - consumer
            process that, on receipt of a data element, consume data in some internal computation

        we can join processes synchronously, or, using semaphores, create a buffer
        [[diagram]]
        solution: bounded circular buffer
            - as an exercise, prove no deadlock or starvation

    - dining philosophers
        [[diagram]]
        5 philosophers working on a problem
        each one has only two states: think and eat
        table has five bowls, and five chopsticks/forks
        a philosopher need two chopsticks to eat
        philosophers may only pick up chopsticks to the left and right

        for the system can operate correctly, it is required that
            - a philosopher only eats when they have two chopsticks
            - no two philosophers can hold the same chopstick simultaneously
        
        solve this algorithmically

            first attempt
                void philosopher(int id) {
                    while(TRUE) {
                        think();            // for some time
                        take_fork(right);   
                        take_fork(left);
                        eat();
                        put_fork(right);
                        put_fork(left);
                    }
                }

                // does this work?
                [[diagram]]
            
            second attempt
                model each fork as a semaphore - semaphorks!
                then each philosopher must wait() for each fork before eating

                semaphore fork [5] := ((5) 1)
                /* pseudo-code */
                /* fork is array of semaphores all initialised to have value 1 */
                process philosopher (i := 0 to 4) {
                    while (1) {
                        think ( );
                        wait(fork (i)); // grab fork[i]
                        wait(fork ((i+1) mod 5); // mod allows for circular
                                                 // table where P4 grabs fork 4 and fork 0
                        eat ( );
                        signal(fork (i)); // release fork[i]
                        signal(fork ((i+1) mod 5); // release rh fork
                    }
                }
                
                // this leads to deadlock, however
                // what happens if everyone grabs their left one first?
                // this can be solved if you order it to be the smallest number fork first
                // so instead of wait(fork ((i + 1) % n));
                // it becomes first get the smaller fork of i mod n and i+1 mod n
                // the get the larger of the two
                /*
                    wait(fork (min(i, i+1 % n)) );
                    wait(fork (max(i, i+1 % n)) );
                */
                // only really makes a difference for philosopher n, as they're reaching for fork n and fork 0

                this is an asymmetric solution
                each philosopher is the same, except due to their position, one philosopher acts wildly differently

                symmetric solution
                    limiting the amount of philosophers allowed to sit at the table

                    /* pseudo-code for room solution to dining philosophers */
                    /* fork is array of semaphores all initialised to have value 1 */
                    semaphore Room := 4
                    semaphore fork (5) := ((5) 1)
                    process philosopher (i := 0 to 4) {
                        while (1) {
                            Think ( ); // thinking not a cs!
                            wait (Room);
                            wait(fork (i));
                            wait(fork ((i+1) mod 5);

                            Eat ( ) // eating is the cs
                            
                            signal(fork (i));
                            signal(fork ((i+1) mod 5);
                            signal (Room);
                        }
                    }

                    // hard-bottlenecking the amount of processes allowed to access resources
            
    - reader-writer problem
        // finish later
    
memory management
    in multiprogramming systems, the user part of memory is subdivided to accomodate multiple processes
    the task of subdivision is carried out by the os, and is known as memory management
        // windows is bad at it lmao
    memory needs to be allocated efficiently to pack as many processes into memory as possible

    requirements
        - relocation
            loading the program dynamically into an arbitrary memory space, whose adress limits are only known at execution time

        - protection
            each process should be protected against unwanted interference from other processes
        
        - sharing
            any protection mechanism should be flexible enough to allow several processes to access the same portion of main memory

    organisation
        - logical
            most programs are organised in modules
                some are unmodifiable, read-/execute-only
                others can be modified
            the os must take care of the possibility of sharing modules across processes
        - physical
            memory should be at least two-level
            the os should hide this fact and perform memory movement without the programmer's knowledge

        [[diagram]]
        memory hierarchy recap

        cache review
            cache hit - data found in cache
            cache miss - data was not in cacge

            [[diagram]]
            - typical computer applications access data with a high degree of locality of reference
                temporal locality:
                    data is requested that has been recently requested already
                spatial locality:
                    data is requested that is stored physically closed to data that was recently requested
            
            - when a system writes data to the cache, it must at some point write that data to main memory following write policies
                write-through
                    write is done synchronously both to cache and main memory
                write-back
                    initially, writing is only done to cache
                    the write to main is postponed until it is about to be replaced by another cache block
            
    process address space
        when accessing memory, a process is said to operate within an address space
            -> data items are accessible within the range of addresses available to the process

        the number of bits allocated to specify the address is an architectural decision
            early computers had 16 bits for addresses, allowing for 2^16 bits of direct addressing
            the 32 bits
            now, most computers have 64 bits for addressing
            we say that such a system gives a virtual address space of 16 exabytes 
                (although physical memory is almost certainly less than this)
            
        address binding
            [[diagram]]
            an address used in an instruction can point anywhere in the virtual address space
                it must still be bound to a physical memory address
            programs are made of modules
            compilers or assemblers do not know where the module will be loaded in physical memory
                addresses must be translated to physical
                two ways of doing this

                static address binding
                    os is responsible for managing the memory, so it will give the loader a base address of here to load the module
                        the loader converts each virtual address in the module to absolute physical addresses by _adding_ the base address
                        this is static binding
                
                    simple, easy to implement
                    however
                        once loaded, the code or data of the program cannot be moved into another part of memory without chanigng the static binding
                        all the processes executing in such a system would share the same physical address space
                            - no protection if an addressing error occurs
                            - even os code is exposed

                dynamic address binding
                    keeps loaded address _relative_ to start of process
                    advantages
                        - a given program can run anywhere and can be moved anywhere by the os
                        - unaware where it is in physical memory, as all locations are relative and virtual
                        - these can isolated using protection mechanisms

                    disadvantages
                        - a mechanism is needed to bind the instructions being executed to the actual locations that they are being executed on