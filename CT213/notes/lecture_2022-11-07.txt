memory management (cont.)
    _hardware assisted_ relocation and protection
        dynamic binding must be implemented in hardware, since it introduces translation at every part of memory access

        the basic requirement for modules is to be held contiguously in physical memory and contain addresses relative to their start location
            - the first location is called the base of the address
        suppose an instruction is fetched and decoded, and contains an address reference
            - this address is relative to the base, so the value of the base mmust be added to it in order for the correct address to be sent to the memory controller

        [[diagram]]

        the simplest form of dynamic binding hardware is a base register and a memory management unit (mmu) to perform the translation
            the os must load the base register as part of setting up the state of a process before passing control to it
        problem:
            this approach provides no protection between processes
            we cannot be sure that a process is not using an address that is not in its address space
        
        [[diagram]]

        solution:
            combine the relocation and protection in on unit
            this is done by adding a limit register that delimits the upper bound of the address space in physical memory

    segmentation and segmented virtual memory
        in practice, it is not very useful for a program to occupy a contiguous range of physical addresses
        such a scheme would prevent two processes from sharing the same code
            e.g. two instances of the same process using different data
        this can be achieved if the system has two base registers and two limit registers, allowing for two separate memory ranges, or two segments per process

        segmented virtual memory
            [[diagram]]
                two processes sharing code segments but having private data segments
            [[diagram]]
                most significant bit of virtual adress is taken as segment identifier, with 0 for data and 1 for code
            [[diagram]]
                - within a single program, it is usual to have separate areas for code, stack, and heap
                - language systems have conventions on how the virtual space is arranged
                    - code segments won't grow in size
                    - heap will grow
                    - stack grows in the oppsite direction
                - in order to realise the relocation, three segments is preferable

        