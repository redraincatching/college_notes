/* INSERTION SORTS */
/* Simplest insertion sort */
void isort1()
{ 
    int i, j;
    for (i = 1; i < n; i++)
    for (j = i; j > 0 && x[j-1] > x[j]; j--)
    swap(j-1, j);
}
/* Write swap function inline */
void isort2()
{ 
    int i, j;
    DType t;
    for (i = 1; i < n; i++) {
        for (j = i; j > 0 && x[j-1] > x[j]; j--) {
            t = x[j];
            x[j] = x[j-1];
            x[j-1] = t;
        }
    }
}
/* Move assignments to and from t out of loop */
void isort3()
{ 
    int i, j;
    DType t;
    for (i = 1; i < n; i++) {
        t = x[i];
        for (j = i; j > 0 && x[j-1] > t; j--)
            x[j] = x[j-1];
            x[j] = t;
    }
}

/* QUICKSORTS */
/* Simplest version, Lomuto partitioning */
void qsort1(int l, int u)
{ int i, m;
 if (l >= u)
 return;
 m = l;
 for (i = l+1; i <= u; i++)
 if (x[i] < x[l])
 swap(++m, i);
 swap(l, m);
 qsort1(l, m-1);
 qsort1(m+1, u);
}
/* Sedgewick's version of Lomuto, with sentinel */
void qsort2(int l, int u)
{ int i, m;
 if (l >= u)
 return;
 m = i = u+1;
 do {
 do i--; while (x[i] < x[l]);
 swap(--m, i);
 } while (i > l);
 qsort2(l, m-1);
 qsort2(m+1, u);
}
/* Two-way partitioning */
void qsort3(int l, int u)
{ int i, j;
 DType t;
 if (l >= u)
 return;
 t = x[l];
 i = l;
 j = u+1;
 for (;;) {
 do i++; while (i <= u && x[i] < t);
 do j--; while (x[j] > t);
 if (i > j)
 break;
 swap(i, j);
 }
 swap(l, j);
 qsort3(l, j-1);
 qsort3(j+1, u);
}
/* qsort3 + randomization + isort small subarrays + swap inline */
int cutoff = 50;
void qsort4(int l, int u)
{ int i, j;
 DType t, temp;
 if (u - l < cutoff)
 return;
 swap(l, randint(l, u));
 t = x[l];
 i = l;
 j = u+1;
 for (;;) {
 do i++; while (i <= u && x[i] < t);
 do j--; while (x[j] > t);
 if (i > j)
 break;
 temp = x[i]; x[i] = x[j]; x[j] = temp;
 }
 swap(l, j);
 qsort4(l, j-1);
 qsort4(j+1, u);
}