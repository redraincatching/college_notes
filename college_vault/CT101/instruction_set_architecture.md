# instruction set architecture

includes the microprocessor's architecture set, the set of all the assembly language instructions that the microprocessor can execute
specifies:
- the registers accessible to the programmer, their size, and the instructions that can access them
- information necessary to interact with the memory, e.g. alignment
- how microprocessors react to interrupts

### programming languages
###### high-level language
- hides details about the computer and os
- platform independent
###### assembly language
- platform dependent
- processors are usually made to be backwards compatible
###### machine language
- contains the binary values that cause the processor to perform certain operations
- platform specific

### compiling native code
![[compiling_native_code.png]]
compiler
- checks to see if every line in the code is valid
- once the program is _syntax error_ free, it generates object code (machine language equivalent to source code)
- at this point, the program has been compiled successfully, but it is not ready to execute

linking
- some programs need object code from other programs or libraries
- a linker combines your object code with this other code
- the combined code is stored as an executable file
- a loader copies that file into memory, for the microprocessor to run

### assembling programs
![[assembling_programs.png]]
- assembly languages (e.g. x86, ARM) are specific to one microcontroller
- converts the source code into object code
- linker then combines with other object code

_// note: java does all of this differently_

---
## RISC vs CISC
#### CISC - complex instruction set computers
the belief that better performance would come from reducing the number of instructions used led to the development of processors with very complex instructions
- fewer instructions necessary to execute a task
- take less storage space than RISC programs
- arithmetic and other operations can read and write operands directly to and from memory
#### RISC - reduced instruction set computers
architectures with a simpler set of instructions
- simpler instructions executed faster
- cheaper to implement (less complex internal microarchitecture)
- only load and store are used to access internal memory

example: addition of two operands in memory, written to memory

>RISC
> ```generic RISC
> LD R4, (R1)
> LD R4, (R1)
> LD R5, (R2)
> ADD R6, R4, R5
> ST (R3), R6
> ```

> CISC
> ```generic CISC
> ADD (R3), (R2), (R1)
> ```

 /\*
between the LD instruction accessing memory, the RISC architecture can add more instructions that don't access memory, whereas the CISC has no option but to wait for the ADD operation to execute, which may delay other instructions
\*/

---
## instruction types
data transfer
- move data from one place to another, without modifying it

data operation
- perform some operation on their operand(s), and store it, typically

program control
- jump or branch instructions used to go to another part of the program, can be absolute or conditional
- specific instructions that can generate interrupts

### data transfer instructions
- load data from memory into the microprocessor
- store data from microprocessor in memory
- move data within microprocessor
- input data to the microprocessor
&nbsp;&nbsp;&nbsp;&nbsp;-> take data from the input device, e.g. the keyboard
- output data from microprocessor
&nbsp;&nbsp;&nbsp;&nbsp;-> copies data from internal registers to output device

### data operation instructions
arithmetic instructions
- ADD, SUB, INC, DEC, FMUL, FDIV...

logic instructions
- AND, OR, XOR, NOT...

shift instructions
- SL, SR, RR, RL...

### program control instructions
- jump or branch instructions
- comparison instructions
- call and return from a routine instructions
- specific instructions to generate interrupts, or hardware interrupts generated by outside devices
- exceptions and traps
 &nbsp;&nbsp;&nbsp;&nbsp;caused when valid instructions perform invalid operations, e.g. dividing by 0
 - halt instructions

---
## data types
a microprocessor must operate with multiple data types
this has a direct implication on the architecture set
-> the designer needs to include instructions to perform operations on these different types
-> numeric representation
- unsigned and signed integers
- floating point numbers

-> boolean data
- true is nonzero, false is a zero value

-> character data
- stored as binary
- the microprocessor might need to manipulate the character data directly

--- 
## instruction format
represented as a binary value with a specific format, called the instruction code
made out of groups of bits
- opcode: the instruction identifier
- operands: to be operated on
![[instruction_formats.png]]
fewer operations mean more instructions to complete the task
the fewer operands, the simpler the hardware can be in implementation

_// note: in practice, some instructions are far larger, and the opcode is just an address pointing to the full instruction_

---
## CPU elements
program counter - PC
- contains the address of the instruction to be executed next

[[cpu_programming_models#stack based architecture|stack]]
- hardware stack -> has physical limitations
- memory-implemented stack -> limited by the memory of the system
	- can be used to explicitly save/restore data
	- used implicitly by procedure call instructions
- instruction register - IR
	- holds the current instruction being processed
	- not exposed in instruction set architecture, just for organisational purposes

##### implicit stack usage
![[implicit_stack_usage.png]]
CALL
- before the jump to the PR address, the call instruction saves the PC in the stack

RETURN
- extracts the address of the PC before the jump, and restores it

##### explicit stack usage
typical stack operations, assuming the stack grows from higher addresses to lower ones

PUSH (X):
- (SP)= (SP)-1
- ((SP)) = X

POP (X)
- X = ((SP))
- (SP) = (SP)+1


> #computing_systems 