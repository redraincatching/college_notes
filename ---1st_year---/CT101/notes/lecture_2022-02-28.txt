gpr example processor
    consider a simple gpr architecture
        32 registers, r0-r31
        value of r0 is always 0
    data types
        8-bit bytes, 16-bit half-words, 32-bit words (integer data)
        operations work on 32-bit integers
        8- and 16-bit operands are loaded into the 32-bit registers with the sign bit duplicated
    addressing modes
        immediate (16-bit field)
        displacement mode (contents of register added to the 16-bit address field)

    GPR instruction examples
        I-type instructions
            [diagram]
            e.g.
                LW R2, 50 (R3)      ;R2 <- 50 + contents(R3)
                BNEZ R4, name       ;if(contents(R4) != 0) PC <- name, BNEZ "branch not equal zero"
        R-type instructions
            [diagram]
            e.g.
                ADD r1, r2, r3      ;r1 <- (r2) + (r3)
        J-type instructions
            [diagram]
            e.g.
                J name              ;PC <- name
                JAL name            ;r(31) <- PC+4, PC <- name      "jump and link"

    // NOTE: see MIPS architecture

    example processor implementation
        [diagram, but like, what even is this one?]
        instruction fetch (IF)
            cycle
                - IR <- Mem[PC]         ;PC here is program counter
                - NPC <- PC+4
            operation
                send out the PC, and fetch the instruction from memory
                increment the PC by 4 to address the next instruction, and store it in NPC, the Next Program Counter, register

        instruction decode (ID)
            "register fetch"
            cycle
                - A <- Regs[IR_6…_10]               ;bits 6 to 10
                - B <- Regs[IR_11…_15]              ;bits 11 to 15
                - Imm <- ((IR_16)^16##IR_16…_31)    ;sign extending bits 16 to 31
            operation
                - decode the instruction, and access the register files to access the registers; the output of the general-purpose registers are read into two temporary registers, A and B, for use in later clock cycles
                - the lower 16 bits of IR are also _sign extended_, and stored in the temporary register Imm, for later use

        instruction execution (EX)
            "effective address"
            cycle
                - memory reference instruction
                    ALUOutput <- A + Imm
                        the ALU reads the operands to form the effective address, and places the result into the register ALUOutput
                - register ALU instruction
                    ALUOutput <- A func B
                        the ALU performs the specified instruction, and places the result into ALUOutput
                - immediate ALU instruction
                    ALUOutput <- A op Imm
                        ALU performs the operation indicated by the opcode on the value from A and Imm, and result is placed in ALUOutput
                - branch instruction
                    ALUOutput <- NPC + Imm
                    Cond <- (A op 0)
                        the ALU adds the contents of NPC with the sign extended value of Imm to compute the address of the branch target, register A is checked to see if the branch is taken
                        the comparison operation op is determined by the branch opcode (e.g. op is "==" for instruction BQEZ)

        instruction memory access (MEM)
            "branch completion"
            cycle
                memory reference instruction
                    - load
                        LMD <- Mem[ALUOutput]
                    - store
                        Mem[ALUOutput] <- B
                    - access memory if needed
                        if instruction is a load, then data returns from memory and is placed in LMD register (load memory data)
                        if instruction is a store, then the data from B register is written back into memory, at the location stored in the previous cycle in ALUOutput
                branch instruction
                    if (cond) {PC<-ALUOutput} else {PC<-NPC}
                        if the instruction branches, then the PC is replaced with branch destination address, otherwise it is replaced with the incremented PC, stored in NPC

        instruction write-back (WB)
            cycle
                - register ALU instruction
                    Regs[IR_16…_20]<-ALUOutput
                - immediate ALU instruction
                    Regs[IR_11…_15]<-ALUOutput
                - load instruction
                    Regs[IR_11…_15]<-LMD

                    write the results back into the register file, whether the data comes from the main memory, or as a result of an operation (from ALU); the register destination can be in two positions, and is determined by the instruction type

pipeline
    pipelining is an implementation technique whereby multiple instructions are overlapped in an execution
        - the goal of the pipeline is to reduce the execution time for a set of instructions
        - key for most modern processors
    each stage in the pipeline completes a part of the instruction
    throughput is determined by how often an instruction exits the pipeline (i.e. gets completed)

    basic pipeline
        [diagram]
        we can pipeline the presented datapath with no changes by starting a new instruction on each clock cycle
        [diagram]

        the use of pipeline forces us to think about the following:
            - datapaths should use separate instructions and data memories
                the memory system should deliver five times the bandwidth
                // NOTE: bandwidth is maximum rate of data transfer across a given path

            - the register file is used in two stages: for reading in ID stage, and for writing in WB stage
                this means we need to be able to do, at maximum, two reads and a write every clock cycle
                // what if a read and a write target the same register?
            - to start a new instruction every clock cycle, PC has to be incremented and stored every cycle, and this should be done in IF, during preparation for next instruction
                the problem occurs when we consider the effect of taken branches, that change the PC as well, but not until the MEM stage
                we'll deal with this by reorganising the way the PC gets written

        pipelining the datapath requires that values passed from one pipe stage to the next be placed in registers. those registers, placed between each stage, are called pipeline registers
            they serve to convey data and control information from one stage to the next
            IF/ID, ID/EX, EX/MEM, MEM/WB
            PC can also be thought of as a pipeline register, that sits before the IF phase of an instruction, leading to one pipeline register for each stage

        most of the data flows left to right, which is to say from earlier to later in time.
            the paths that flow rtl, whcih carry the PC and values for the WB stage, introduce complications into our pipeline

            [diagram]
    pipelined instruction fetch
        instruction fetch
            - IF/ID.IR <- mem[PC]
            - IF/ID.NPC, PC <- If (EX/MEM.cond) {EX/MEM.ALUOutput}else{PC+4}
        operation
            send out the PC and fetch the instruction from memory
            increment the PC by 4 to address the next instruction or save the address generated by a taken branch of a previous instruction in execution stage

    pipelined instruction decode
        // TODO: finish this, also separate slides with the extra text

    performance issues with pipelining - pipeline overhead
        increases the processor throughput
        does _not_ increase individual execution speed
            actually decreases it a little, thanks to delay when writing to and reading from pipeline registers
            however, the total program will have a lower total execution time
        physical limits on pipeline
            imbalance between stages, as the clock can only run as fast as the slowest stage (clock skew)

        performance computation
            consider our original example
                the ALU uses four cycles
                the relative freq. of ALU operations is 40%, and branches, 20%
                clock cycle is 10ns
            let the pipeline overhead be 1ns

            average instruction execution time is, for the unpipelined example
                clock cycle * average CPI (cycles per instruction)
                    = 10 ns * [(40% + 20%)*4 + 40% * 5]
                    = 44ns
            pipelined example
