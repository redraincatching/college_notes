fractional conversion methods

    variation of the division method
        repeatedly multiply by the new base
            record every digit that moves left of the point
            that becomes the next value of the new number, after the point
                drop that number
                repeat until required precision is achieved, or until remaining number is 0

    fractional conversions between bases of 2^n
        grouping goes left to right, method is otherwise identical

representing negative numbers

    common schemas
        sign-magnitude
        complementary representations
            - 1's / 9's complement
            - 2's / 10's complement

    sign magnitude
        leftmost bit represents +ve or -ve
            behaves like a flag
        1 is negative
        0 is positive
            // this takes up a bit, so extra storage
                // so the very first step is to decide on the number of bits to use to represent the number

        difficulties involved

            two representations of 0
                -0: 10000000
                +0: 00000000

            arithmetic involved is difficult
                more complexity in hardware necessary to implement an ALU
                                                                (arithmetic and logic unit)

    complementary notation

        9's (decimal) and 1's (binary) complement
            - decide the number of digits (word length) to represent the numbers
            - represent the negative numbers by the largest number minus the absolute value of the negative number
                  example
                    2-digit 9's complement of -12
                        99 - 12 = 87    // get back the value by inverting this again

                    8-digit 1's complement of -101
                        11111111 - 101 = 11111010

            positive numbers map directly using half of the total combinations
            negative numbers map onto the other half of the numbers
                so above, in the 2 digit 9's complement of 12, 0-49 are +(0-49)
                    and 50-99 are -(0-49)

            failings
                again, two representations of 0
                arithmetic is still pretty awkward

        10's (decimal) and 2's (binary) complement

            similar, but represent the negative number as largest number + 1, minus absolute value
                removes the second 0, as two digits will never include the other 0

                examples
                    2-digits 10's complement of -12
                        100 - 12 = 88

                    8-digit 2's complement of -101
                        100000000 - 101 = 11111011
                            // do a 1's complement, then add one after flipping the bits

                // this representation can hold one extra negative number
                    // e.g., 2-digit 10s ranges from -50 to 49

                // also note, just 9's complement with 1 added
