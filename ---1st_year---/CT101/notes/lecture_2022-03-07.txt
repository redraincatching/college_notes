pipeline hazards
    situations that prevent the next instruction in the stream from executing in its designated clock cycle
    hazards reduce the performance from the ideal speedup gained by pipelining
    three types
        - structural hazards
            arise from resource conflicts when the hardware can't support all possible combinations of overlapping instructions
            come from physical limitations, e.g. the limited number of registers
        - data hazards
            arise when an instruction depends on the results of a previous instruction in a way that is exposed by overlapping instructions in the pipeline
            come from when instructions access the same registers
        - control hazards
            arise from the pipelining and branches and other instructions that change the PC

    stall
        hazards in the pipeline can cause a stall
            forcing an instruction to take more clock cycles than necessary to complete
        eliminating a hazard often requires that some instructions can proceed while others are delated
            when an instruction is stalled, any instructions that come later are affected, while earlier instructions must continue
        no new instructions can be fetched during a stall

    structural hazards
        if certain combinations of instructions can't be accommodated because of resource conflicts, then the machine has structural hazards

        can be generated by
            - a functional unit that is not fully pipelined
            - resources not being duplicated enough to allow all combinations in the pipeline to execute
            e.g.
                a machine may only have one file write port, but under certain circumstances, the pipeline may want to perform two writes in one clock cycle
            consider a von neumann architecture
            [diagram]
            [diagram]
            a stall cycle is added, also known as the pipeline bubble
            [diagram]

        a machine with structural hazards will have a higher cpi
            a designer might still, however, allow them for cost or latency purposes

    data hazards
        occur when the pipeline changes the order of read/write accesses to operands, so that the order differs from those seen by sequentially executing instructions on an un-pipelined machine
        take this sequence of instructions:
            ADD r1, r2, r3
            SUB R4, R1, R5
            AND r6, r1, r7
            OR r8, r1, r9
            XOR r10, r1, r11
            [diagram]
        the use of results from ADD case a hazard because the register is not written to until after the other instructions have read from it
        [diagram]
        the hazards can be eliminated using a technique known as forwarding
            // ess. reading directly from the ALU, and not waiting until it is in the register
        [diagram]
            store requires an operand during MEM and forwarding is shown here
            the result of the load is forwarded from the output in MEM/WB to the memory input to be stored
            in addition, the ALUOutput is forwarded to ALUInput for address calculation for both load and store

        data hazard classifications
            depending on the order of read and write access in the instructions, data hazards can fit into three categories
            consider two instructions, i and j
                - RAW (read after write)
                    j tries to read a source before i writes to it, and j incorrectly gets the old value
                    most common type
                - WAW (write after write)
                    j writes to an operand, and then i overwrites it
                    present in pipelines with more than one writing stage
                - WAR (write after read)
                    j tries to write to a destination before i reads it, and i incorrectly gets the new value

        data hazards requiring stalls
            consider the following sequence
                LW r1, 0(r2)
                SUB r4, r1, r5
                AND r6, r1, r7
                OR r8, r1, r9
            the problem here is that the load operation will not have data until the end of the MEM stage
            [diagram]
                the load can forward results to the AND and OR operations, but not to sub, as that would require forwarding results in negative time
            [diagram]
                the load interlock causes a stall to be inserted at clock cycle 4, which then allows forwarding

        compiler scheduling for data hazards
            [diagram]
            consider A = B + C
                the add must be stalled to allow the load of C to complete
                the SW does not need to be delayed, due to forwarding
            rather than just allow the pipeline to stall, the compiler can try to rearrange the code to avoid this
                this technique is known as pipeline scheduling
            consider
                A = B + C
                D = E - F
            solution
                LW rb, B
                LW rc, C
                LW re, E    ;to avoid the stall
                ADD ra, rb, rc
                LW rf, F
                SW A, ra
                SUB rd, re, rf
                sw D, rD

    control hazards
        can cause a greater performance loss than that of data hazards
        when a branch is executed, it may or may not change the PC
            the branch can either be taken, or robert frost
        if instruction i is a taken branch, then the value of pc will not change until the end MEM stage of the pipeline
            a simple method to deal with branches would be to simply stall a branch once it is detected, until we know whether it will be taken or not
        [diagram]
        a branch causes a three-cycle stall in our example pipeline
            one cycle is a repeated IF, necessary if the branch is taken, redundant if not
            two stall cycles
            this is a massive decrease, and can be reduced if we are able to find out if the branch is taken or not earlier
