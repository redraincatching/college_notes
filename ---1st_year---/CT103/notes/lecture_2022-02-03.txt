memory requirements
    different variables have different space requirements
    sizeof() returns the size (in bytes) of any variable you pass to it, including structs and bytes

    we store variables in ram, and we can use &<variable> to access its address

pointers
    definition
        a variable whose value is the address of another variable

    %p is the placeholder for the stored address
        // note: prints leading zeroes, unlike %x

    * operator
        used to define a pointer
        e.g.
            char c;
            char* c_point = &c;    // defines a character pointer, and passes it the address of c

    dereferencing
        using a pointer to get to the variable
        e.g.
            printf("here is a character: %c", *c_point);        // <- dereferencing
            printf("and here is its address: %p", c_point);     // not dereferencing

            // or
            *c_point = 'a';   // assigning a new character to c

    pointers and arrays
        e.g.
            int arr_a[5] = {1, 2, 3, 4, 5};
            int* ap_0 = arr_a;          // now points to the 0th element of the array

            // note: this only points to a single element, not the full array
            // if we needed to pass the array to a function, for example, passing *ap wouldn't compile

            int (*ap_1)[5] = &arr_a;    // this points to the full array
                                        // basically an array of pointers

            pointers and strings
                char string[] = "test sentence";

                char* cp;
                cp = string;    // a string name often evaluates to a pointer to the string
                puts(cp);       // this is referred to as the array "decaying" to a pointer

                cp = &string;
                puts(cp);
                cp = &string[0];
                puts(cp);
                // both of these work, as puts() starts printing from the address passed to it

    pointers and functions
        if a function expects a pointer as an argument, an array of the same type can also be passed to it, as arrays decay to pointers

        e.g.
            void do_thing(int* p){
                // do thing
            }

            void main() {
                int arr[2] = {1, 5};
                do_thing(arr);      // works fine
            }

    incrementing pointers
        when we increment a pointer (e.g. with ++), we're not adding one, we're adding the size of the data type in bytes to the pointer
            this is what causes errors when you increment a pointer out of bounds

        e.g.
            num[2] = {1, 5};
            int* ip = num;
            for (int i = 0; i < 2; i++) {
                printf("%d ", *(ip+1));
            }
            // prints "1, 5"
